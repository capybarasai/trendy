{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trendy","text":""},{"location":"references/","title":"References","text":""},{"location":"references/cli/","title":"Cli","text":""},{"location":"references/cli/#cli","title":"CLI","text":""},{"location":"references/cli/#sm_trendy.cli.agg","title":"<code>agg(config_file)</code>","text":"<p>Aggregate the downloaded results into single files</p> <p>For example, <code>s3://sm-google-trend/configs/aggregate_config.json</code></p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>AnyPath</code> <p>location of a config file that contains the configurations and the keywords</p> required Source code in <code>sm_trendy/cli.py</code> <pre><code>@trendy.command()\n@click.argument(\"config-file\", type=AnyPath)\ndef agg(config_file: AnyPath):\n\"\"\"Aggregate the downloaded results into single files\n\n    For example, `s3://sm-google-trend/configs/aggregate_config.json`\n\n    :param config_file: location of a config file that contains\n        the configurations and the keywords\n    \"\"\"\n    click.echo(f\"Aggregation config: {click.format_filename(str(config_file))}\")\n    if not isinstance(config_file, AnyPath):\n        config_file = AnyPath(config_file)\n\n    with open(config_file, \"r\") as fp:\n        config = json.load(fp)\n\n    parent_folder = AnyPath(config[\"global\"][\"path\"][\"parent_folder\"])\n    agg_bundle = AggSerpAPIBundle(parent_path=parent_folder)\n\n    for k in config[\"keywords\"]:\n        keyword_configs = AnyPath(k[\"config\"])\n        logger.info(f\"Aggregating {keyword_configs}\")\n        agg_bundle(serpapi_config_path=keyword_configs)\n</code></pre>"},{"location":"references/cli/#sm_trendy.cli.agg_metadata","title":"<code>agg_metadata(config_file)</code>","text":"<p>Convert configs to a json file that our website can get a list of keywords and their corresponding path, for visualizations.</p> <p><code>config_file</code> should have the same format as aggregation config, e.g., <code>s3://sm-google-trend/configs/aggregate_config.json</code></p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>AnyPath</code> <p>location of a config file that contains the configurations and the keywords</p> required Source code in <code>sm_trendy/cli.py</code> <pre><code>@trendy.command()\n@click.argument(\"config-file\", type=AnyPath)\ndef agg_metadata(config_file: AnyPath):\n\"\"\"Convert configs to a json file that our\n    website can get a list of keywords and\n    their corresponding path, for visualizations.\n\n    `config_file` should have the same format as aggregation config, e.g., `s3://sm-google-trend/configs/aggregate_config.json`\n\n    :param config_file: location of a config file that contains\n        the configurations and the keywords\n    \"\"\"\n    click.echo(f\"Using aggregation config: {click.format_filename(str(config_file))}\")\n\n    if not isinstance(config_file, AnyPath):\n        config_file = AnyPath(config_file)\n\n    with open(config_file, \"r\") as fp:\n        config = json.load(fp)\n\n    parent_folder = AnyPath(config[\"global\"][\"path\"][\"parent_folder\"])\n\n    if not isinstance(parent_folder, S3Path):\n        raise Exception(f\"parent folder is not S3Path: {parent_folder}\")\n\n    s3_public_region = \"eu-central-1\"\n    s3_public_folder = (\n        parent_folder.key[:-1] if parent_folder.key.endswith(\"/\") else parent_folder.key\n    )\n    s3_public_base_url = f\"https://{parent_folder.bucket}.s3.{s3_public_region}.amazonaws.com/{s3_public_folder}\"\n    all_config = []\n    for k in config[\"keywords\"]:\n        keyword_configs = AnyPath(k[\"config\"])\n        logger.info(f\"Parsing {keyword_configs}\")\n\n        scb = SerpAPIConfigBundle(file_path=keyword_configs, serpapi_key=\"\")\n\n        for c in scb:\n            logger.debug(f\"  Converting {c.path_params}\")\n            # URL of the data file\n            c_url = c.path_params.s3_access_point(\n                base_url=s3_public_base_url,\n                snapshot_date=\"latest\",\n                filename=\"data.json\",\n            )\n\n            # Build Path Config\n            all_config.append(\n                {\n                    \"keyword\": c.path_params.keyword,\n                    \"cat\": c.path_params.cat,\n                    \"geo\": c.path_params.geo,\n                    \"timeframe\": c.path_params.timeframe,\n                    \"path\": c_url,\n                }\n            )\n\n    # save all to a metadata.json file\n    target_path = parent_folder / \"metadata.json\"\n    logger.info(f\"Saving metadata to {target_path} ...\")\n    with target_path.open(\"w+\") as fp:\n        json.dump(all_config, fp)\n</code></pre>"},{"location":"references/cli/#sm_trendy.cli.create_manual_folders","title":"<code>create_manual_folders(config_file, manual_folder)</code>","text":"<p>Create folders based on the serpapi config</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>AnyPath</code> <p>location of a config file that contains the configurations and the keywords</p> required Source code in <code>sm_trendy/cli.py</code> <pre><code>@trendy.command()\n@click.argument(\"config-file\", type=AnyPath)\n@click.argument(\"manual-folder\", type=AnyPath)\ndef create_manual_folders(config_file: AnyPath, manual_folder: AnyPath):\n\"\"\"Create folders based on the serpapi config\n\n    :param config_file: location of a config file that contains\n        the configurations and the keywords\n    \"\"\"\n    click.echo(click.format_filename(config_file))\n\n    scb = SerpAPIConfigBundle(file_path=config_file, serpapi_key=\"\")\n    if not isinstance(manual_folder, AnyPath):\n        manual_folder = AnyPath(manual_folder)\n    s2m = SerpAPI2Manual(manual_folder=manual_folder)\n    logger.info(f\"Create intermediate folders in {manual_folder} ...\")\n    s2m(config_bundle=scb)\n</code></pre>"},{"location":"references/cli/#sm_trendy.cli.download_pytrends","title":"<code>download_pytrends(config_file)</code>","text":"<p>Download trends based on the config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>AnyPath</code> <p>location of a config file that contains the configurations and the keywords</p> required Source code in <code>sm_trendy/cli.py</code> <pre><code>@trendy.command()\n@click.argument(\"config-file\", type=click.Path(exists=True))\ndef download_pytrends(config_file: AnyPath):\n\"\"\"Download trends based on the config file\n\n    :param config_file: location of a config file that contains\n        the configurations and the keywords\n    \"\"\"\n    click.echo(click.format_filename(config_file))\n\n    cb = ptc.ConfigBundle(file_path=config_file)\n\n    today = datetime.date.today()\n    global_request_params = cb.global_config[\"request\"]\n    parent_folder = cb.global_config[\"path\"][\"parent_folder\"]\n    trends_service = ptg._TrendReq(\n        hl=global_request_params[\"hl\"],\n        tz=global_request_params[\"tz\"],\n        timeout=(10, 14),\n        requests_args={\"headers\": get_random_user_agent()},\n        proxies=[\"https://157.245.27.9:3128\"],\n    )\n\n    dl = ptg.Download(\n        parent_folder=parent_folder,\n        snapshot_date=today,\n        trends_service=trends_service,\n    )\n\n    wait_seconds_min_max = (30, 120)\n\n    for c in cb:\n        dl(c)\n        wait_seconds = random.randint(*wait_seconds_min_max)\n        logger.info(f\"Waiting for {wait_seconds} seconds ...\")\n        time.sleep(wait_seconds)\n</code></pre>"},{"location":"references/cli/#sm_trendy.cli.download_serpapi","title":"<code>download_serpapi(config_file)</code>","text":"<p>Download trends based on the config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>AnyPath</code> <p>location of a config file that contains the configurations and the keywords</p> required Source code in <code>sm_trendy/cli.py</code> <pre><code>@trendy.command()\n@click.argument(\"config-file\", type=AnyPath)\ndef download_serpapi(config_file: AnyPath):\n\"\"\"Download trends based on the config file\n\n    :param config_file: location of a config file that contains\n        the configurations and the keywords\n    \"\"\"\n    click.echo(click.format_filename(config_file))\n\n    today = datetime.date.today()\n\n    api_key = os.environ.get(\"SERPAPI_KEY\")\n    if api_key is None:\n        logger.error(\"api_key is empty, please set the env var: \" \"SERPAPI_KEY\")\n\n    scb = SerpAPIConfigBundle(file_path=config_file, serpapi_key=api_key)\n\n    parent_folder = scb.global_config[\"path\"][\"parent_folder\"]\n    sdl = SerpAPIDownload(parent_folder=parent_folder, snapshot_date=today)\n\n    wait_seconds_min_max = (0, 1)\n\n    for c in scb:\n        try:\n            sdl(c)\n            wait_seconds = random.randint(*wait_seconds_min_max)\n            logger.info(f\"Waiting for {wait_seconds} seconds ...\")\n            time.sleep(wait_seconds)\n        except Exception as e:\n            logger.error(\"Can not download: \\n\" f\"config: {c}\\n\" f\" error: {e}\")\n</code></pre>"},{"location":"references/cli/#sm_trendy.cli.upload_manual","title":"<code>upload_manual(config_file, manual_folder)</code>","text":"<p>Download trends based on the config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>AnyPath</code> <p>location of a config file that contains the configurations and the keywords</p> required Source code in <code>sm_trendy/cli.py</code> <pre><code>@trendy.command()\n@click.argument(\"config-file\", type=AnyPath)\n@click.argument(\"manual-folder\", type=AnyPath)\ndef upload_manual(config_file: AnyPath, manual_folder: AnyPath):\n\"\"\"Download trends based on the config file\n\n    :param config_file: location of a config file that contains\n        the configurations and the keywords\n    \"\"\"\n    click.echo(click.format_filename(config_file))\n\n    today = datetime.date.today()\n\n    scb = SerpAPIConfigBundle(file_path=config_file, serpapi_key=\"\")\n\n    parent_folder = scb.global_config[\"path\"][\"parent_folder\"]\n    mdl = ManualDownload(\n        parent_folder=parent_folder, snapshot_date=today, manual_folder=manual_folder\n    )\n\n    for c in scb:\n        try:\n            mdl(c)\n        except Exception as e:\n            logger.error(\"Can not download: \\n\" f\"config: {c}\\n\" f\" error: {e}\")\n</code></pre>"},{"location":"references/cli/#sm_trendy.cli.validate_config","title":"<code>validate_config(config_file, top_n)</code>","text":"<p>Validate config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>AnyPath</code> <p>location of a config file that contains the configurations and the keywords</p> required <code>top_n</code> <code>int</code> <p>top n to be displayed</p> required Source code in <code>sm_trendy/cli.py</code> <pre><code>@trendy.command()\n@click.argument(\"config-file\", type=AnyPath)\n@click.argument(\"top-n\", type=int, default=10)\ndef validate_config(config_file: AnyPath, top_n: int):\n\"\"\"Validate config file\n\n    :param config_file: location of a config file that contains\n        the configurations and the keywords\n    :param top_n: top n to be displayed\n    \"\"\"\n    click.echo(f\"Validating {click.format_filename(str(config_file))} ...\")\n\n    scb = SerpAPIConfigBundle(file_path=config_file, serpapi_key=\"\")\n\n    ct = ConfigTable(scb)\n    console = Console()\n    console.print(ct.table(top_n=top_n))\n\n    api_key = os.environ.get(\"SERPAPI_KEY\")\n    console.print(f\"SERPAPI_KEY Exists: {api_key is not None}\")\n\n    for c in scb:\n        try:\n            c._validate()\n        except Exception as e:\n            logger.error(f\"Keyword: {c.serpapi_params.q} validation failed: {e}\")\n</code></pre>"},{"location":"references/aggregate/agg/","title":"Manual - Agg","text":""},{"location":"references/aggregate/agg/#aggregateagg","title":"<code>aggregate.agg</code>","text":""},{"location":"references/aggregate/agg/#sm_trendy.aggregate.agg.AggAPIJSON","title":"<code>AggAPIJSON</code>","text":"<p>Generate clean and API usable json data</p> <p>AggAPIJSON takes in a dataframe as raw data, cleans it up, and convert it to dictionary that is suitable for JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Optional[Dict[str, str]]</code> <p>a dictionary that maps the original columns to the desired keys in the result</p> <code>None</code> Source code in <code>sm_trendy/aggregate/agg.py</code> <pre><code>class AggAPIJSON:\n\"\"\"\n    Generate clean and API usable json data\n\n    AggAPIJSON takes in a dataframe as raw data,\n    cleans it up, and convert it to dictionary\n    that is suitable for JSON format.\n\n    :param fields: a dictionary that maps the original\n        columns to the desired keys in the result\n    \"\"\"\n\n    def __init__(self, fields: Optional[Dict[str, str]] = None):\n        if fields is None:\n            fields = {\n                \"query\": \"query\",\n                \"extracted_value\": \"value\",\n                \"date\": \"date\",\n            }\n        self.fields = fields\n        self.keep_columns = list(fields.keys())\n\n    def __call__(\n        self, dataframe: pd.DataFrame, sort_by: Optional[str] = None\n    ) -&gt; List[Dict]:\n        df = dataframe.copy()\n        df = df[self.keep_columns]\n        df.rename(columns=self.fields, inplace=True)\n        records = df.to_dict(orient=\"records\")\n\n        if sort_by is not None:\n            records = sorted(records, key=lambda x: x[sort_by])\n\n        return records\n</code></pre>"},{"location":"references/aggregate/agg/#sm_trendy.aggregate.agg.AggSerpAPIBundle","title":"<code>AggSerpAPIBundle</code>","text":"<p>Aggregate all data from a whole serpapi config file</p> <p>In this class, we follow the following flow</p> <ol> <li>Recreate the SerpAPIConfigBundle</li> <li>Loop through each config in SerpAPIConfigBundle     a. retrieve the data from each of the config     b. convert the selected data to json     c. save it to a new folder with the same path pattern.</li> </ol> Source code in <code>sm_trendy/aggregate/agg.py</code> <pre><code>class AggSerpAPIBundle:\n\"\"\"\n    Aggregate all data from a whole serpapi config file\n\n    In this class, we follow the following flow\n\n    1. Recreate the SerpAPIConfigBundle\n    2. Loop through each config in SerpAPIConfigBundle\n        a. retrieve the data from each of the config\n        b. convert the selected data to json\n        c. save it to a new folder with the same path pattern.\n    \"\"\"\n\n    def __init__(self, parent_path: AnyPath):\n        self.parent_path = parent_path\n\n    def __call__(self, serpapi_config_path: AnyPath):\n        # ReCreate the bundle config for SerpAPI\n        scb = SerpAPIConfigBundle(file_path=serpapi_config_path, serpapi_key=\"\")\n        scb_parent_folder = scb.global_config[\"path\"][\"parent_folder\"]\n\n        # Instantiate the data loader\n        dll_k = DownloadedLoader(parent_folder=scb_parent_folder, from_format=\"csv\")\n\n        # Loop through the serpapi configs\n        logger.info(f\"  Looping through {len(scb)} configs\")\n        for c in scb:\n            logger.debug(f\"  Aggregating {c}\")\n            # Path of the raw downloaded data\n            c_path = c.path_params.path(parent_folder=scb_parent_folder)\n            # Raw dataframe\n            c_df = dll_k(c.path_params)\n\n            # aggregate\n            c_agg_json = AggAPIJSON()\n            c_records = c_agg_json(dataframe=c_df, sort_by=\"date\")\n\n            # save snapshot\n            c_snapshot_date = dll_k._latest_snapshots(c_path / \"format=csv\")\n            c_k_target_path = c.path_params.path(parent_folder=self.parent_path)\n            logger.debug(\n                f\"Saving data to {c_k_target_path} with snapshot {c_snapshot_date}...\"\n            )\n            self._store_json(\n                snapshot_date=datetime.date.fromisoformat(c_snapshot_date),\n                target_folder=c_k_target_path,\n                records=c_records,\n            )\n\n            # save a copy as latest\n            logger.debug(f\"Saving data to {c_k_target_path} with snapshot latest ...\")\n            self._store_json(\n                snapshot_date=\"latest\", target_folder=c_k_target_path, records=c_records\n            )\n\n    def _store_json(\n        self,\n        snapshot_date: Union[datetime.date, Literal[\"latest\"]],\n        target_folder: AnyPath,\n        records: List[Dict],\n    ) -&gt; None:\n\"\"\"\n        Save the `records` as json files inside the folder `target_folder`\n\n        :param snapshot_date: a specific snapshot date to use used as a folder name\n        :param target_folder: where to save the data\n        :param records: data records to be saved\n        \"\"\"\n        store_json = StoreJSON(\n            target_folder=target_folder,\n            snapshot_date=snapshot_date,\n        )\n        store_json.save(records=records, formats=[\"json\"])\n</code></pre>"},{"location":"references/aggregate/agg/#sm_trendy.aggregate.agg.DownloadedLoader","title":"<code>DownloadedLoader</code>","text":"<p>Load downloaded data as parquet</p> <p>Warning</p> <p>Currently, this class only downloads the latest snapshot.</p> <p>!!! todo:     Allow downloading any snapshot(s)</p> <p>Parameters:</p> Name Type Description Default <code>parent_folder</code> <code>AnyPath</code> <p>parent folder of the downloaded dataset</p> required <code>from_format</code> <code>Optional[Literal['csv', 'parquet']]</code> <p>which format to load the data from</p> <code>'csv'</code> Source code in <code>sm_trendy/aggregate/agg.py</code> <pre><code>class DownloadedLoader:\n\"\"\"\n    Load downloaded data as parquet\n\n    !!! warning\n        Currently, this class only downloads the latest snapshot.\n\n    !!! todo:\n        Allow downloading any snapshot(s)\n\n    :param parent_folder: parent folder of the downloaded dataset\n    :param from_format: which format to load the data from\n    \"\"\"\n\n    def __init__(\n        self,\n        parent_folder: AnyPath,\n        from_format: Optional[Literal[\"csv\", \"parquet\"]] = \"csv\",\n    ):\n        self.from_format = from_format\n        self.parent_folder = parent_folder\n\n    def _data_path(self, path_params: PathParams) -&gt; AnyPath:\n\"\"\"\n        build the full dataset path\n\n        :param path_params: PathParams to calculate the path patterns\n        \"\"\"\n        data_folder = path_params.path(parent_folder=self.parent_folder)\n\n        if self.from_format == \"csv\":\n            format_path = data_folder / f\"format={self.from_format}\"\n            latest_snapshot = self._latest_snapshots(format_path)\n            path = (\n                format_path\n                / f\"snapshot_date={latest_snapshot}\"\n                / f\"data.{self.from_format}\"\n            )\n        else:\n            raise Exception(f\"Not yet supported: reading from {self.from_format}\")\n\n        return path\n\n    def _load_as_dataframe(self, data_path: AnyPath) -&gt; pd.DataFrame:\n\"\"\"\n        Load the data file as pandas dataframe\n\n        :param data_path: path to the data file\n        \"\"\"\n        if self.from_format == \"csv\":\n            df = pd.read_csv(data_path)\n        else:\n            raise Exception(f\"Not yet supported: reading from {self.from_format}\")\n\n        return df\n\n    def __call__(self, path_params: PathParams) -&gt; pd.DataFrame:\n\"\"\"\n        load the data specified in a PathParams as pandas dataframe\n\n        :param path_params: PathParams to calculate the path patterns\n        \"\"\"\n        data_path = self._data_path(path_params=path_params)\n        df = self._load_as_dataframe(data_path)\n\n        return df\n\n    @staticmethod\n    def _latest_snapshots(path: AnyPath):\n        path_subfolders = list(path.iterdir())\n        logger.debug(f\"subfolders: {path_subfolders} in {path}\")\n\n        re_sd = re.compile(r\"snapshot_date=(\\d{4}-\\d{2}-\\d{2})\")\n\n        snapshot_dates = sum(\n            [re_sd.findall(i.name) for i in path_subfolders], []\n        )  # type: List[str]\n        logger.debug(f\"snapshot_dates: {snapshot_dates}\")\n\n        snapshot_dates_latest = sorted(\n            snapshot_dates, key=lambda x: datetime.date.fromisoformat(x)\n        )[-1]\n\n        return snapshot_dates_latest\n</code></pre>"},{"location":"references/aggregate/agg/#sm_trendy.aggregate.agg.DownloadedLoader.__call__","title":"<code>__call__(path_params)</code>","text":"<p>load the data specified in a PathParams as pandas dataframe</p> <p>Parameters:</p> Name Type Description Default <code>path_params</code> <code>PathParams</code> <p>PathParams to calculate the path patterns</p> required Source code in <code>sm_trendy/aggregate/agg.py</code> <pre><code>def __call__(self, path_params: PathParams) -&gt; pd.DataFrame:\n\"\"\"\n    load the data specified in a PathParams as pandas dataframe\n\n    :param path_params: PathParams to calculate the path patterns\n    \"\"\"\n    data_path = self._data_path(path_params=path_params)\n    df = self._load_as_dataframe(data_path)\n\n    return df\n</code></pre>"},{"location":"references/aggregate/config/","title":"Aggregate - Config","text":""},{"location":"references/aggregate/config/#aggregateconfig","title":"<code>aggregate.config</code>","text":""},{"location":"references/manual/config/","title":"Manual - Config","text":""},{"location":"references/manual/config/#manualconfig","title":"<code>manual.config</code>","text":""},{"location":"references/manual/config/#sm_trendy.manual.config.SerpAPI2Manual","title":"<code>SerpAPI2Manual</code>","text":"<p>Convert SerpAPI config to Manual config, and saves the results as json files.</p> <p>Parameters:</p> Name Type Description Default <code>manual_folder</code> <code>AnyPath</code> <p>intermediate folder to hold the downloaded csv and manual config</p> required Source code in <code>sm_trendy/manual/config.py</code> <pre><code>class SerpAPI2Manual:\n\"\"\"Convert SerpAPI config to Manual config,\n    and saves the results as json files.\n\n    :param manual_folder: intermediate folder to hold the\n        downloaded csv and manual config\n    \"\"\"\n\n    def __init__(self, manual_folder: AnyPath):\n        if manual_folder.exists():\n            assert (\n                len(list(manual_folder.iterdir())) == 0\n            ), \"An empty folder is required\"\n\n        self.manual_folder = manual_folder\n\n    def __call__(self, config_bundle: SerpAPIConfigBundle):\n\"\"\"\n        convert `SerpAPIConfigBundle` to a bunch of folders\n        with manual config inside.\n        \"\"\"\n\n        for c in config_bundle:\n            manual_config = c.path_params.model_dump()\n            c_temp_path = c.path_params.path(parent_folder=self.manual_folder)\n            c_temp_path.mkdir(parents=True, exist_ok=True)\n\n            logger.debug(f'Writing to {c_temp_path / \"manual.json\"} ...')\n            with open(c_temp_path / \"manual.json\", \"w\") as fp:\n                json.dump(manual_config, fp)\n</code></pre>"},{"location":"references/manual/config/#sm_trendy.manual.config.SerpAPI2Manual.__call__","title":"<code>__call__(config_bundle)</code>","text":"<p>convert <code>SerpAPIConfigBundle</code> to a bunch of folders with manual config inside.</p> Source code in <code>sm_trendy/manual/config.py</code> <pre><code>def __call__(self, config_bundle: SerpAPIConfigBundle):\n\"\"\"\n    convert `SerpAPIConfigBundle` to a bunch of folders\n    with manual config inside.\n    \"\"\"\n\n    for c in config_bundle:\n        manual_config = c.path_params.model_dump()\n        c_temp_path = c.path_params.path(parent_folder=self.manual_folder)\n        c_temp_path.mkdir(parents=True, exist_ok=True)\n\n        logger.debug(f'Writing to {c_temp_path / \"manual.json\"} ...')\n        with open(c_temp_path / \"manual.json\", \"w\") as fp:\n            json.dump(manual_config, fp)\n</code></pre>"},{"location":"references/manual/get_trends/","title":"Manual - Trends","text":""},{"location":"references/manual/get_trends/#manualget_trends","title":"<code>manual.get_trends</code>","text":""},{"location":"references/manual/get_trends/#sm_trendy.manual.get_trends.ManualDownload","title":"<code>ManualDownload</code>","text":"<p>Download trend using config</p> <p>Parameters:</p> Name Type Description Default <code>parent_folder</code> <code>AnyPath</code> <p>parent folder for the data</p> required <code>snapshot_date</code> <code>datetime.date</code> <p>snapshot date for the path</p> required <code>trends_service</code> <p>trend service</p> required Source code in <code>sm_trendy/manual/get_trends.py</code> <pre><code>class ManualDownload:\n\"\"\"Download trend using config\n\n    :params parent_folder: parent folder for the data\n    :param snapshot_date: snapshot date for the path\n    :param trends_service: trend service\n    \"\"\"\n\n    def __init__(\n        self,\n        parent_folder: AnyPath,\n        snapshot_date: datetime.date,\n        manual_folder: AnyPath,\n    ):\n        self.parent_folder = parent_folder\n        self.snapshot_date = snapshot_date\n        self.manual_folder = manual_folder\n\n    def __call__(self, config):\n\"\"\"\n        :param config: config for the keyword\n        \"\"\"\n        path_params = config.path_params\n        target_folder = path_params.path(parent_folder=self.parent_folder)\n\n        sdf = StoreDataFrame(\n            target_folder=target_folder, snapshot_date=self.snapshot_date\n        )\n        sst = ManualSingleTrend(\n            path_params=path_params, manual_folder=self.manual_folder\n        )\n\n        logger.info(\n            f\"keyword: {config.serpapi_params.q}\\n\"\n            f\"target_path: {target_folder}\\n\"\n            \"...\"\n        )\n\n        logger.info(f\"Saving to {target_folder} ...\")\n        sdf.save(sst, formats=[\"csv\", \"parquet\"])\n</code></pre>"},{"location":"references/manual/get_trends/#sm_trendy.manual.get_trends.ManualDownload.__call__","title":"<code>__call__(config)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>config</code> <p>config for the keyword</p> required Source code in <code>sm_trendy/manual/get_trends.py</code> <pre><code>def __call__(self, config):\n\"\"\"\n    :param config: config for the keyword\n    \"\"\"\n    path_params = config.path_params\n    target_folder = path_params.path(parent_folder=self.parent_folder)\n\n    sdf = StoreDataFrame(\n        target_folder=target_folder, snapshot_date=self.snapshot_date\n    )\n    sst = ManualSingleTrend(\n        path_params=path_params, manual_folder=self.manual_folder\n    )\n\n    logger.info(\n        f\"keyword: {config.serpapi_params.q}\\n\"\n        f\"target_path: {target_folder}\\n\"\n        \"...\"\n    )\n\n    logger.info(f\"Saving to {target_folder} ...\")\n    sdf.save(sst, formats=[\"csv\", \"parquet\"])\n</code></pre>"},{"location":"references/manual/get_trends/#sm_trendy.manual.get_trends.ManualSingleTrend","title":"<code>ManualSingleTrend</code>","text":"<p>get trend from manually downloaded file</p> Source code in <code>sm_trendy/manual/get_trends.py</code> <pre><code>class ManualSingleTrend:\n\"\"\"get trend from manually downloaded file\"\"\"\n\n    def __init__(self, path_params: PathParams, manual_folder: AnyPath):\n        self.path_params = path_params\n        self.manual_folder = manual_folder\n\n    @cached_property\n    def dataframe(self) -&gt; pd.DataFrame:\n\"\"\"\n        Build the dataframe\n        \"\"\"\n\n        temp_path = self.path_params.path(parent_folder=self.manual_folder)\n        temp_path.mkdir(parents=True, exist_ok=True)\n\n        with open(temp_path / \"manual.json\", \"r\") as fp:\n            manual_config = json.load(fp)\n\n        df_downloaded = pd.read_csv(temp_path / \"multiTimeline.csv\", skiprows=2)\n        columns = df_downloaded.columns.tolist()\n        value_column = [c for c in columns if c != \"Week\"][0]\n\n        df_downloaded.rename(\n            columns={\n                \"Week\": \"date\",\n                value_column: \"extracted_value\",\n            },\n            inplace=True,\n        )\n\n        df_downloaded[\"query\"] = manual_config[\"keyword\"]\n        df_downloaded[\"geo\"] = manual_config[\"geo\"]\n        df_downloaded[\"timeframe\"] = manual_config[\"timeframe\"]\n        df_downloaded[\"cat\"] = manual_config[\"cat\"]\n\n        return df_downloaded\n\n    @cached_property\n    def metadata(self) -&gt; Dict[str, Dict]:\n        return {\"path\": self.path_params.model_dump()}\n</code></pre>"},{"location":"references/manual/get_trends/#sm_trendy.manual.get_trends.ManualSingleTrend.dataframe","title":"<code>dataframe: pd.DataFrame</code>  <code>cached</code> <code>property</code>","text":"<p>Build the dataframe</p>"},{"location":"references/use_pytrends/config/","title":"Manual - Config","text":""},{"location":"references/use_pytrends/config/#use_pytrendsconfig","title":"<code>use_pytrends.config</code>","text":""},{"location":"references/use_pytrends/config/#sm_trendy.use_pytrends.config.Config","title":"<code>Config</code>","text":"<p>Config for downloading trends</p> <p>Parameters:</p> Name Type Description Default <code>request_params</code> <code>RequestParams</code> <p>params for the TrendReq</p> required <code>trend_params</code> <code>TrendParams</code> <p>params for SingleTrend</p> required <code>path_params</code> <code>PathParams</code> <p>params to build the path</p> required Source code in <code>sm_trendy/use_pytrends/config.py</code> <pre><code>class Config:\n\"\"\"\n    Config for downloading trends\n\n    :param request_params: params for the TrendReq\n    :param trend_params: params for SingleTrend\n    :param path_params: params to build the path\n    \"\"\"\n\n    def __init__(\n        self,\n        request_params: RequestParams,\n        trend_params: TrendParams,\n        path_params: PathParams,\n    ):\n        self.request_params = request_params\n        self.trend_params = trend_params\n        self.path_params = path_params\n\n    @classmethod\n    def from_dict(cls, config: Dict) -&gt; Config:\n\"\"\"\n        Load config from a dictionary\n\n        ```python\n        config = {\n            \"request\": {\n                \"tz\": 120,\n                \"hl\": \"en-US\"\n            },\n            \"trend\": {\n                \"timeframe\": \"today 5-y\",\n                \"cat\": 0,\n                \"geo\": \"DE\",\n                \"keyword\": \"phone case\"\n            },\n            \"path\": {\n                \"keyword\": \"phone case\",\n                \"cat\": \"all\",\n                \"country\": \"DE\",\n                \"frequency\": \"1W\"\n            }\n        }\n        ```\n\n        :param config: config dictionary that contains\n            the key and values to build the params\n        \"\"\"\n\n        request_params = RequestParams(**config[\"request\"])\n        trend_params = TrendParams(**config[\"trend\"])\n        path_config = convert_path(config[\"path\"])\n        path_params = PathParams(**path_config)\n\n        return Config(\n            request_params=request_params,\n            trend_params=trend_params,\n            path_params=path_params,\n        )\n\n    def _validate(self):\n        assert (\n            self.trend_params.keyword == self.path_params.keyword\n        ), \"trend keyword and path keyword should match\"\n</code></pre>"},{"location":"references/use_pytrends/config/#sm_trendy.use_pytrends.config.Config.from_dict","title":"<code>from_dict(config)</code>  <code>classmethod</code>","text":"<p>Load config from a dictionary</p> <pre><code>config = {\n    \"request\": {\n        \"tz\": 120,\n        \"hl\": \"en-US\"\n    },\n    \"trend\": {\n        \"timeframe\": \"today 5-y\",\n        \"cat\": 0,\n        \"geo\": \"DE\",\n        \"keyword\": \"phone case\"\n    },\n    \"path\": {\n        \"keyword\": \"phone case\",\n        \"cat\": \"all\",\n        \"country\": \"DE\",\n        \"frequency\": \"1W\"\n    }\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>config dictionary that contains the key and values to build the params</p> required Source code in <code>sm_trendy/use_pytrends/config.py</code> <pre><code>@classmethod\ndef from_dict(cls, config: Dict) -&gt; Config:\n\"\"\"\n    Load config from a dictionary\n\n    ```python\n    config = {\n        \"request\": {\n            \"tz\": 120,\n            \"hl\": \"en-US\"\n        },\n        \"trend\": {\n            \"timeframe\": \"today 5-y\",\n            \"cat\": 0,\n            \"geo\": \"DE\",\n            \"keyword\": \"phone case\"\n        },\n        \"path\": {\n            \"keyword\": \"phone case\",\n            \"cat\": \"all\",\n            \"country\": \"DE\",\n            \"frequency\": \"1W\"\n        }\n    }\n    ```\n\n    :param config: config dictionary that contains\n        the key and values to build the params\n    \"\"\"\n\n    request_params = RequestParams(**config[\"request\"])\n    trend_params = TrendParams(**config[\"trend\"])\n    path_config = convert_path(config[\"path\"])\n    path_params = PathParams(**path_config)\n\n    return Config(\n        request_params=request_params,\n        trend_params=trend_params,\n        path_params=path_params,\n    )\n</code></pre>"},{"location":"references/use_pytrends/config/#sm_trendy.use_pytrends.config.ConfigBundle","title":"<code>ConfigBundle</code>","text":"<p>Build a list of configs from file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>AnyPath</code> <p>path to the file</p> required Source code in <code>sm_trendy/use_pytrends/config.py</code> <pre><code>class ConfigBundle:\n\"\"\"Build a list of configs from file\n\n    :param file_path: path to the file\n    \"\"\"\n\n    def __init__(self, file_path: AnyPath):\n        self.file_path = file_path\n        raw_configs = self._load_json(self.file_path)\n        self.configs, self.global_config = self._combine_configs(\n            raw_configs=raw_configs\n        )\n\n    def _combine_configs(self, raw_configs: Dict) -&gt; Tuple[List[Config], Dict]:\n        global_config = self._transform_raw_global_config(raw_configs[\"global\"])\n\n        combined_configs = [\n            self._combine_with_global(global_config=global_config, keyword_config=k)\n            for k in raw_configs[\"keywords\"]\n        ]\n\n        return combined_configs, global_config\n\n    @staticmethod\n    def _transform_raw_global_config(raw_global_config: Dict) -&gt; Dict:\n\"\"\"\n        Convert string to path object if exist\n        \"\"\"\n        global_config = copy.deepcopy(raw_global_config)\n\n        if \"path\" in global_config:\n            global_config[\"path\"] = convert_path(global_config[\"path\"])\n\n        return global_config\n\n    @staticmethod\n    def _combine_with_global(global_config: Dict, keyword_config: Dict) -&gt; Config:\n        new_keyword_config = {}\n\n        for key in [\"request\", \"trend\", \"path\"]:\n            new_keyword_config[key] = keyword_config.get(key, {}) | global_config.get(\n                key, {}\n            )\n\n        return Config.from_dict(new_keyword_config)\n\n    @staticmethod\n    def _load_json(file_path: AnyPath) -&gt; Dict:\n\n        with open(file_path, \"r\") as fp:\n            data = json.load(fp)\n\n        return data\n\n    def __getitem__(self, idx: int) -&gt; Config:\n        return self.configs[idx]\n\n    def __len__(self) -&gt; int:\n        return len(self.configs)\n\n    def __iter__(self):\n        for item in self.configs:\n            yield item\n</code></pre>"},{"location":"references/use_pytrends/config/#sm_trendy.use_pytrends.config.RequestParams","title":"<code>RequestParams</code>","text":"<p>Parameters for trend</p> <ol> <li>Get tz info from here.</li> </ol> Source code in <code>sm_trendy/use_pytrends/config.py</code> <pre><code>@dataclass\nclass RequestParams:\n\"\"\"\n    Parameters for trend\n\n    1. Get tz info from [here](https://forbrains.co.uk/international_tools/earth_timezones).\n    \"\"\"\n\n    tz: int = 120\n    hl: str = \"en-US\"\n    headers: Optional[Dict] = None\n    timeout: Optional[Tuple] = (5, 14)\n    proxies: Optional[Dict] = None\n</code></pre>"},{"location":"references/use_pytrends/get_trends/","title":"Manual - Trends","text":""},{"location":"references/use_pytrends/get_trends/#use_pytrendsget_trends","title":"<code>use_pytrends.get_trends</code>","text":""},{"location":"references/use_pytrends/get_trends/#sm_trendy.use_pytrends.get_trends.Download","title":"<code>Download</code>","text":"<p>Download trend using config</p> <pre><code>config_file = ...\ncb = ConfigBundle(file_path=config_file)\n\ntoday = datetime.date.today()\nglobal_request_params = cb.global_config[\"request\"]\nparent_folder = cb.global_config[\"path\"][\"parent_folder\"]\ntrends_service = _TrendReq(\n    hl=global_request_params[\"hl\"],\n    tz=global_request_params[\"tz\"],\n    timeout=(10, 14),\n    requests_args={\"headers\": get_random_user_agent()},\n    proxies=[\"https://157.245.27.9:3128\"],\n)\n\ndl = Download(\n    parent_folder=parent_folder,\n    snapshot_date=today,\n    trends_service=trends_service,\n)\n\nwait_seconds_min_max = (30, 120)\n\nfor c in cb:\n    dl(c)\n    wait_seconds = random.randint(*wait_seconds_min_max)\n    logger.info(f\"Waiting for {wait_seconds} seconds ...\")\n    time.sleep(wait_seconds)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>parent_folder</code> <code>AnyPath</code> <p>parent folder for the data</p> required <code>snapshot_date</code> <code>datetime.date</code> <p>snapshot date for the path</p> required <code>trends_service</code> <code>_TrendReq</code> <p>trend service</p> required Source code in <code>sm_trendy/use_pytrends/get_trends.py</code> <pre><code>class Download:\n\"\"\"Download trend using config\n\n    ```python\n    config_file = ...\n    cb = ConfigBundle(file_path=config_file)\n\n    today = datetime.date.today()\n    global_request_params = cb.global_config[\"request\"]\n    parent_folder = cb.global_config[\"path\"][\"parent_folder\"]\n    trends_service = _TrendReq(\n        hl=global_request_params[\"hl\"],\n        tz=global_request_params[\"tz\"],\n        timeout=(10, 14),\n        requests_args={\"headers\": get_random_user_agent()},\n        proxies=[\"https://157.245.27.9:3128\"],\n    )\n\n    dl = Download(\n        parent_folder=parent_folder,\n        snapshot_date=today,\n        trends_service=trends_service,\n    )\n\n    wait_seconds_min_max = (30, 120)\n\n    for c in cb:\n        dl(c)\n        wait_seconds = random.randint(*wait_seconds_min_max)\n        logger.info(f\"Waiting for {wait_seconds} seconds ...\")\n        time.sleep(wait_seconds)\n    ```\n\n    :params parent_folder: parent folder for the data\n    :param snapshot_date: snapshot date for the path\n    :param trends_service: trend service\n    \"\"\"\n\n    def __init__(\n        self,\n        parent_folder: AnyPath,\n        snapshot_date: datetime.date,\n        trends_service: _TrendReq,\n    ):\n        self.parent_folder = parent_folder\n        self.snapshot_date = snapshot_date\n        self.trends_service = trends_service\n\n    def __call__(self, config: Config):\n\"\"\"\n        :param config: config for the keyword\n        \"\"\"\n\n        trend_params = config.trend_params\n        path_params = config.path_params\n        target_folder = path_params.path(parent_folder=self.parent_folder)\n        sdf = StoreDataFrame(\n            target_folder=target_folder, snapshot_date=self.snapshot_date\n        )\n\n        logger.info(\n            f\"keyword: {trend_params.keyword}\\n\" f\"target_path: {target_folder}\\n\" \"...\"\n        )\n\n        st = SingleTrend(\n            trends_service=self.trends_service,\n            keyword=trend_params.keyword,\n            geo=trend_params.geo,\n            timeframe=trend_params.timeframe,\n            cat=trend_params.cat,\n        )\n\n        sdf.save(st, formats=[\"csv\", \"parquet\"])\n        logger.info(f\"Saved to {target_folder}\")\n</code></pre>"},{"location":"references/use_pytrends/get_trends/#sm_trendy.use_pytrends.get_trends.Download.__call__","title":"<code>__call__(config)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>config for the keyword</p> required Source code in <code>sm_trendy/use_pytrends/get_trends.py</code> <pre><code>def __call__(self, config: Config):\n\"\"\"\n    :param config: config for the keyword\n    \"\"\"\n\n    trend_params = config.trend_params\n    path_params = config.path_params\n    target_folder = path_params.path(parent_folder=self.parent_folder)\n    sdf = StoreDataFrame(\n        target_folder=target_folder, snapshot_date=self.snapshot_date\n    )\n\n    logger.info(\n        f\"keyword: {trend_params.keyword}\\n\" f\"target_path: {target_folder}\\n\" \"...\"\n    )\n\n    st = SingleTrend(\n        trends_service=self.trends_service,\n        keyword=trend_params.keyword,\n        geo=trend_params.geo,\n        timeframe=trend_params.timeframe,\n        cat=trend_params.cat,\n    )\n\n    sdf.save(st, formats=[\"csv\", \"parquet\"])\n    logger.info(f\"Saved to {target_folder}\")\n</code></pre>"},{"location":"references/use_pytrends/get_trends/#sm_trendy.use_pytrends.get_trends.SingleTrend","title":"<code>SingleTrend</code>","text":"<p>Get the trend for one keyword, in one country</p> <p><code>trends_service</code> can be instatiated using</p> <pre><code>trends_service = _TrendReq(hl=\"en-US\", tz=120)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>trends_service</code> <code>_TrendReq</code> <p>pytrends TrendReq</p> required <code>geo</code> <code>str</code> <p>geo code such as <code>\"DE\"</code></p> required <code>timeframe</code> <code>str</code> <p>the time frame of the trend, see pytrends</p> <code>'today 5-y'</code> <code>cat</code> <code>int</code> <p>category code, see pytrends for a list.</p> <code>0</code> Source code in <code>sm_trendy/use_pytrends/get_trends.py</code> <pre><code>class SingleTrend:\n\"\"\"Get the trend for one keyword, in one country\n\n    `trends_service` can be instatiated using\n\n    ```python\n    trends_service = _TrendReq(hl=\"en-US\", tz=120)\n    ```\n\n    :param trends_service: pytrends TrendReq\n    :param geo: geo code such as `\"DE\"`\n    :param timeframe: the time frame of the trend, see pytrends\n    :param cat: category code, see pytrends for a list.\n    \"\"\"\n\n    def __init__(\n        self,\n        trends_service: _TrendReq,\n        keyword: str,\n        geo: str,\n        timeframe: str = \"today 5-y\",\n        cat: int = 0,\n    ):\n        self.trends_service = trends_service\n        self.keyword = keyword\n        self.cat = cat\n        self.geo = geo\n        self.timeframe = timeframe\n\n        self.timestamp = datetime.datetime.now()\n\n    @cached_property\n    def dataframe(self) -&gt; pd.DataFrame:\n\"\"\"\n        Build the dataframe\n\n        :param keyword: keyword to be searched\n        \"\"\"\n\n        if not isinstance(self.keyword, str):\n            raise Exception(f\"Requires str as keyword input, got {type(self.keyword)}\")\n\n        logger.debug(f\"building payload for {self.keyword} ...\")\n        self.trends_service.build_payload(\n            [self.keyword], cat=self.cat, timeframe=self.timeframe, geo=self.geo\n        )\n\n        logger.debug(f\"Downloading trend for {self.keyword} ...\")\n        df = self.trends_service.interest_over_time()\n\n        return df\n\n    @cached_property\n    def metadata(self) -&gt; Dict[str, Union[str, int]]:\n        return {\n            \"timestamp\": self.timestamp.isoformat(),\n            \"keyword\": self.keyword,\n            \"geo\": self.geo,\n            \"timeframe\": self.timeframe,\n            \"cat\": self.cat,\n        }\n</code></pre>"},{"location":"references/use_pytrends/get_trends/#sm_trendy.use_pytrends.get_trends.SingleTrend.dataframe","title":"<code>dataframe: pd.DataFrame</code>  <code>cached</code> <code>property</code>","text":"<p>Build the dataframe</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <p>keyword to be searched</p> required"},{"location":"references/use_serpapi/config/","title":"SERPAPI - Config","text":""},{"location":"references/use_serpapi/config/#user_serpapiconfig","title":"<code>user_serpapi.config</code>","text":""},{"location":"references/use_serpapi/config/#sm_trendy.use_serpapi.config.SerpAPIConfig","title":"<code>SerpAPIConfig</code>","text":"<p>Config for downloading trends</p> <p>Parameters:</p> Name Type Description Default <code>trend_params</code> <p>params for SingleTrend</p> required <code>path_params</code> <code>PathParams</code> <p>params to build the path</p> required Source code in <code>sm_trendy/use_serpapi/config.py</code> <pre><code>class SerpAPIConfig:\n\"\"\"\n    Config for downloading trends\n\n    :param trend_params: params for SingleTrend\n    :param path_params: params to build the path\n    \"\"\"\n\n    def __init__(\n        self,\n        serpapi_params: SerpAPIParams,\n        path_params: PathParams,\n    ):\n        self.serpapi_params = serpapi_params\n        self.path_params = path_params\n\n    @classmethod\n    def from_dict(cls, config: Dict) -&gt; SerpAPIConfig:\n\"\"\"\n        Load config from a dictionary\n\n        ```python\n        raw_config = {\n            \"serpapi\": {\n                \"date\": \"today 5-y\",\n                \"cat\": \"0\",\n                \"geo\": \"DE\",\n                \"q\": \"phone case\",\n                \"tz\": \"120\"\n            }\n        }\n        ```\n\n        :param config: config dictionary that contains\n            the key and values to build the params\n        \"\"\"\n\n        serpapi_params = SerpAPIParams(**config[\"serpapi\"])\n        path_params = PathParams(\n            **{\n                \"keyword\": serpapi_params.q,\n                \"cat\": serpapi_params.cat,\n                \"geo\": serpapi_params.geo,\n                \"timeframe\": serpapi_params.date,\n            }\n        )\n\n        return SerpAPIConfig(\n            serpapi_params=serpapi_params,\n            path_params=path_params,\n        )\n\n    def _validate(self):\n        assert (\n            self.serpapi_params.q == self.path_params.keyword\n        ), \"trend keyword and path keyword should match\"\n\n        assert (\n            self.serpapi_params.geo == self.path_params.geo\n        ), \"trend geo and path geo should match\"\n\n        assert hasattr(self.serpapi_params, \"q\"), \"serpapi_params should have q\"\n        assert hasattr(self.serpapi_params, \"geo\"), \"serpapi_params should have geo\"\n</code></pre>"},{"location":"references/use_serpapi/config/#sm_trendy.use_serpapi.config.SerpAPIConfig.from_dict","title":"<code>from_dict(config)</code>  <code>classmethod</code>","text":"<p>Load config from a dictionary</p> <pre><code>raw_config = {\n    \"serpapi\": {\n        \"date\": \"today 5-y\",\n        \"cat\": \"0\",\n        \"geo\": \"DE\",\n        \"q\": \"phone case\",\n        \"tz\": \"120\"\n    }\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>config dictionary that contains the key and values to build the params</p> required Source code in <code>sm_trendy/use_serpapi/config.py</code> <pre><code>@classmethod\ndef from_dict(cls, config: Dict) -&gt; SerpAPIConfig:\n\"\"\"\n    Load config from a dictionary\n\n    ```python\n    raw_config = {\n        \"serpapi\": {\n            \"date\": \"today 5-y\",\n            \"cat\": \"0\",\n            \"geo\": \"DE\",\n            \"q\": \"phone case\",\n            \"tz\": \"120\"\n        }\n    }\n    ```\n\n    :param config: config dictionary that contains\n        the key and values to build the params\n    \"\"\"\n\n    serpapi_params = SerpAPIParams(**config[\"serpapi\"])\n    path_params = PathParams(\n        **{\n            \"keyword\": serpapi_params.q,\n            \"cat\": serpapi_params.cat,\n            \"geo\": serpapi_params.geo,\n            \"timeframe\": serpapi_params.date,\n        }\n    )\n\n    return SerpAPIConfig(\n        serpapi_params=serpapi_params,\n        path_params=path_params,\n    )\n</code></pre>"},{"location":"references/use_serpapi/config/#sm_trendy.use_serpapi.config.SerpAPIConfigBundle","title":"<code>SerpAPIConfigBundle</code>","text":"<p>Build a list of configs from file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>AnyPath</code> <p>path to the file</p> required Source code in <code>sm_trendy/use_serpapi/config.py</code> <pre><code>class SerpAPIConfigBundle:\n\"\"\"Build a list of configs from file\n\n    :param file_path: path to the file\n    \"\"\"\n\n    def __init__(self, file_path: AnyPath, serpapi_key: Optional[str] = None):\n        self.file_path = file_path\n        self.serpapi_key = serpapi_key\n        self.raw_configs = self._load_json(self.file_path)\n\n    @property\n    def configs(self) -&gt; List[SerpAPIConfig]:\n\n        return self._combine_configs(raw_configs=self.raw_configs)\n\n    @property\n    def global_config(self) -&gt; Dict:\n        return self._transform_raw_global_config(self.raw_configs[\"global\"])\n\n    def _combine_configs(self, raw_configs: Dict) -&gt; List[SerpAPIConfig]:\n        global_config = self._transform_raw_global_config(raw_configs[\"global\"])\n\n        combined_configs = [\n            self._combine_with_global(\n                global_config=global_config,\n                keyword_config=k,\n                serpapi_key=self.serpapi_key,\n            )\n            for k in raw_configs[\"keywords\"]\n        ]\n\n        return combined_configs\n\n    @staticmethod\n    def _transform_raw_global_config(raw_global_config: Dict) -&gt; Dict:\n\"\"\"\n        Convert string to path object if exist\n        \"\"\"\n        global_config = copy.deepcopy(raw_global_config)\n\n        if \"path\" in global_config:\n            global_config[\"path\"] = convert_path(global_config[\"path\"])\n\n        return global_config\n\n    @staticmethod\n    def _combine_with_global(\n        global_config: Dict, keyword_config: Dict, serpapi_key: Optional[str] = None\n    ) -&gt; SerpAPIConfig:\n        new_keyword_config = {}\n\n        for key in [\"serpapi\"]:\n            new_keyword_config[key] = keyword_config.get(key, {}) | global_config.get(\n                key, {}\n            )\n            if serpapi_key is not None:\n                new_keyword_config[key][\"api_key\"] = serpapi_key\n\n        return SerpAPIConfig.from_dict(new_keyword_config)\n\n    @staticmethod\n    def _load_json(file_path: AnyPath) -&gt; Dict:\n\n        with open(file_path, \"r\") as fp:\n            data = json.load(fp)\n\n        return data\n\n    def __getitem__(self, idx: int) -&gt; SerpAPIConfig:\n        return self.configs[idx]\n\n    def __len__(self) -&gt; int:\n        return len(self.configs)\n\n    def __iter__(self):\n        for item in self.configs:\n            yield item\n\n    def __add__(self, o: List[Dict]):\n        keywords = self.raw_configs[\"keywords\"]\n        keywords.extend(o)\n        self.raw_configs[\"keywords\"] = keywords\n\n    def save_json(self, target_file_path: AnyPath):\n\"\"\"save raw config to path\n\n        :param target_file_path: where to save the json file\n        \"\"\"\n        logger.info(f\"Saving to path {target_file_path}\")\n        with open(target_file_path, \"w\") as fp:\n            json.dump(self.raw_configs, fp)\n</code></pre>"},{"location":"references/use_serpapi/config/#sm_trendy.use_serpapi.config.SerpAPIConfigBundle.save_json","title":"<code>save_json(target_file_path)</code>","text":"<p>save raw config to path</p> <p>Parameters:</p> Name Type Description Default <code>target_file_path</code> <code>AnyPath</code> <p>where to save the json file</p> required Source code in <code>sm_trendy/use_serpapi/config.py</code> <pre><code>def save_json(self, target_file_path: AnyPath):\n\"\"\"save raw config to path\n\n    :param target_file_path: where to save the json file\n    \"\"\"\n    logger.info(f\"Saving to path {target_file_path}\")\n    with open(target_file_path, \"w\") as fp:\n        json.dump(self.raw_configs, fp)\n</code></pre>"},{"location":"references/use_serpapi/config/#sm_trendy.use_serpapi.config.SerpAPIParams","title":"<code>SerpAPIParams</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>SerpAPI docs: https://serpapi.com/google-trends-api</p> <pre><code>sc = SerpAPIParams(\n    **{\n        \"api_key\": \"\",\n        \"q\": \"Coffee\",\n        \"geo\": \"DE\",\n        \"data_type\": \"TIMESERIES\",\n        \"tz\": \"120\",\n    }\n)\n\n# Convert the config to python dictionary\nsc.dict(exclude_none=True)\n</code></pre> Source code in <code>sm_trendy/use_serpapi/config.py</code> <pre><code>class SerpAPIParams(BaseModel):\n\"\"\"\n\n    SerpAPI docs:\n    https://serpapi.com/google-trends-api\n\n    ```python\n    sc = SerpAPIParams(\n        **{\n            \"api_key\": \"\",\n            \"q\": \"Coffee\",\n            \"geo\": \"DE\",\n            \"data_type\": \"TIMESERIES\",\n            \"tz\": \"120\",\n        }\n    )\n\n    # Convert the config to python dictionary\n    sc.dict(exclude_none=True)\n    ```\n    \"\"\"\n\n    api_key: str\n    engine: str = \"google_trends\"\n    q: str\n    geo: Optional[str] = None\n    data_type: Literal[\n        \"TIMESERIES\", \"GEO_MAP\", \"GEO_MAP_0\", \"RELATED_TOPICS\", \"RELATED_QUERIES\"\n    ] = \"TIMESERIES\"\n    tz: Optional[str] = \"120\"\n    cat: Optional[Literal[\"0\"]] = None\n    date: Literal[\n        \"now 1-H\",\n        \"now 4-H\",\n        \"now 1-d\",\n        \"now 7-d\",\n        \"today 1-m\",\n        \"today 3-m\",\n        \"today 12-m\",\n        \"today 5-y\",\n        \"all\",\n    ] = \"today 5-y\"\n\n    @field_validator(\"date\")\n    @classmethod\n    def date_match_allowed(cls, v: str, info: FieldValidationInfo):\n        allowed = [\n            \"now 1-H\",\n            \"now 4-H\",\n            \"now 1-d\",\n            \"now 7-d\",\n            \"today 1-m\",\n            \"today 3-m\",\n            \"today 12-m\",\n            \"today 5-y\",\n            \"all\",\n        ]\n        if v not in allowed:\n            raise ValueError(f\"date must be one of {allowed}\")\n\n        return v\n</code></pre>"},{"location":"references/use_serpapi/get_trends/","title":"SERPAPI - Trends","text":""},{"location":"references/use_serpapi/get_trends/#user_serpapiget_trends","title":"<code>user_serpapi.get_trends</code>","text":""},{"location":"references/use_serpapi/get_trends/#sm_trendy.use_serpapi.get_trends.SerpAPIDownload","title":"<code>SerpAPIDownload</code>","text":"<p>Download trend using config</p> <p>Parameters:</p> Name Type Description Default <code>parent_folder</code> <code>AnyPath</code> <p>parent folder for the data</p> required <code>snapshot_date</code> <code>datetime.date</code> <p>snapshot date for the path</p> required <code>trends_service</code> <p>trend service</p> required Source code in <code>sm_trendy/use_serpapi/get_trends.py</code> <pre><code>class SerpAPIDownload:\n\"\"\"Download trend using config\n\n    :params parent_folder: parent folder for the data\n    :param snapshot_date: snapshot date for the path\n    :param trends_service: trend service\n    \"\"\"\n\n    def __init__(\n        self,\n        parent_folder: AnyPath,\n        snapshot_date: datetime.date,\n    ):\n        self.parent_folder = parent_folder\n        self.snapshot_date = snapshot_date\n\n    def __call__(self, config: SerpAPIConfig):\n\"\"\"\n        :param config: config for the keyword\n        \"\"\"\n        api_params = config.serpapi_params.model_dump(exclude_none=True)\n\n        path_params = config.path_params\n        target_folder = path_params.path(parent_folder=self.parent_folder)\n\n        sdf = StoreDataFrame(\n            target_folder=target_folder, snapshot_date=self.snapshot_date\n        )\n\n        logger.info(\n            f\"keyword: {config.serpapi_params.q}\\n\"\n            f\"target_path: {target_folder}\\n\"\n            \"...\"\n        )\n\n        sst = SerpAPISingleTrend(serpapi_params=api_params)\n\n        sdf.save(sst, formats=[\"csv\", \"parquet\"])\n        logger.info(f\"Saved to {target_folder}\")\n</code></pre>"},{"location":"references/use_serpapi/get_trends/#sm_trendy.use_serpapi.get_trends.SerpAPIDownload.__call__","title":"<code>__call__(config)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>config</code> <code>SerpAPIConfig</code> <p>config for the keyword</p> required Source code in <code>sm_trendy/use_serpapi/get_trends.py</code> <pre><code>def __call__(self, config: SerpAPIConfig):\n\"\"\"\n    :param config: config for the keyword\n    \"\"\"\n    api_params = config.serpapi_params.model_dump(exclude_none=True)\n\n    path_params = config.path_params\n    target_folder = path_params.path(parent_folder=self.parent_folder)\n\n    sdf = StoreDataFrame(\n        target_folder=target_folder, snapshot_date=self.snapshot_date\n    )\n\n    logger.info(\n        f\"keyword: {config.serpapi_params.q}\\n\"\n        f\"target_path: {target_folder}\\n\"\n        \"...\"\n    )\n\n    sst = SerpAPISingleTrend(serpapi_params=api_params)\n\n    sdf.save(sst, formats=[\"csv\", \"parquet\"])\n    logger.info(f\"Saved to {target_folder}\")\n</code></pre>"},{"location":"references/use_serpapi/get_trends/#sm_trendy.use_serpapi.get_trends.SerpAPISingleTrend","title":"<code>SerpAPISingleTrend</code>","text":"Source code in <code>sm_trendy/use_serpapi/get_trends.py</code> <pre><code>class SerpAPISingleTrend:\n    def __init__(self, serpapi_params: SerpAPIParams):\n        self.serpapi_params = serpapi_params\n\n    @cached_property\n    def search_results(self):\n        api_params = self.serpapi_params\n\n        search = GoogleSearch(api_params)\n        results = search.get_dict()\n\n        self._check_status(results[\"search_metadata\"][\"status\"])\n\n        return results\n\n    def _check_status(self, status: str):\n        if not status == \"Success\":\n            raise Exception(f\"Request failed with error {status}\")\n\n    @cached_property\n    def dataframe(self) -&gt; pd.DataFrame:\n\"\"\"\n        Build the dataframe\n\n        :param keyword: keyword to be searched\n        \"\"\"\n        if \"interest_over_time\" not in self.search_results:\n            raise Exception(\n                f\"interest_over_time is not found: {self.search_results.keys()}\\n\"\n                f\"{self.search_results}\"\n            )\n\n        timeline_data = self.search_results[\"interest_over_time\"][\"timeline_data\"]\n\n        df = pd.DataFrame(\n            sum([self._flatten_record(record) for record in timeline_data], [])\n        )\n\n        df[\"date\"] = pd.to_datetime(df.timestamp.astype(int), unit=\"s\", origin=\"unix\")\n\n        return df\n\n    @staticmethod\n    def _flatten_record(record: Dict):\n\"\"\"Convert raw record to flattened dicts\"\"\"\n        return [\n            {**i, **{\"date_range\": record[\"date\"], \"timestamp\": record[\"timestamp\"]}}\n            for i in record[\"values\"]\n        ]\n\n    @cached_property\n    def metadata(self) -&gt; Dict[str, Dict]:\n        return {\n            \"search_metadata\": self.search_results[\"search_metadata\"],\n            \"search_parameters\": self.search_results[\"search_parameters\"],\n        }\n</code></pre>"},{"location":"references/use_serpapi/get_trends/#sm_trendy.use_serpapi.get_trends.SerpAPISingleTrend.dataframe","title":"<code>dataframe: pd.DataFrame</code>  <code>cached</code> <code>property</code>","text":"<p>Build the dataframe</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <p>keyword to be searched</p> required"},{"location":"references/utilities/config/","title":"Utilities - Config","text":""},{"location":"references/utilities/config/#utilities-config","title":"Utilities - Config","text":""},{"location":"references/utilities/config/#sm_trendy.utilities.config.ConfigTable","title":"<code>ConfigTable</code>","text":"<p>ConfigBundle to table</p> <p>Parameters:</p> Name Type Description Default <code>config_bundle</code> <p>serpapi config bundle</p> required Source code in <code>sm_trendy/utilities/config.py</code> <pre><code>class ConfigTable:\n\"\"\"\n    ConfigBundle to table\n\n    :param config_bundle: serpapi config bundle\n    \"\"\"\n\n    def __init__(self, config_bundle):\n        self.config_bundle = config_bundle\n\n    def table(self, top_n: int = 10):\n\"\"\"\n        :param top_n: only display the top_n configs\n        \"\"\"\n        parent_folder = self.config_bundle.global_config.get(\"path\", {}).get(\n            \"parent_folder\"\n        )\n        n_configs = len(self.config_bundle)\n        table = Table(\n            title=(\n                f\"Configs: {n_configs};\\n\"\n                f\"Path: {str(parent_folder)};\\n\"\n                f\"Top N: {top_n}\"\n            ),\n            show_lines=True,\n        )\n\n        table.add_column(\"q\", justify=\"right\", style=\"cyan\", no_wrap=False)\n        table.add_column(\"cat\", style=\"magenta\", no_wrap=False)\n        table.add_column(\"geo\", style=\"magenta\", no_wrap=False)\n        table.add_column(\"timeframe\", style=\"magenta\", no_wrap=False)\n\n        for idx, c in enumerate(self.config_bundle):\n            if idx &gt; top_n:\n                break\n            else:\n                table.add_row(\n                    c.serpapi_params.q,\n                    c.serpapi_params.cat,\n                    c.serpapi_params.geo,\n                    c.serpapi_params.date,\n                )\n\n        return table\n</code></pre>"},{"location":"references/utilities/config/#sm_trendy.utilities.config.ConfigTable.table","title":"<code>table(top_n=10)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>top_n</code> <code>int</code> <p>only display the top_n configs</p> <code>10</code> Source code in <code>sm_trendy/utilities/config.py</code> <pre><code>def table(self, top_n: int = 10):\n\"\"\"\n    :param top_n: only display the top_n configs\n    \"\"\"\n    parent_folder = self.config_bundle.global_config.get(\"path\", {}).get(\n        \"parent_folder\"\n    )\n    n_configs = len(self.config_bundle)\n    table = Table(\n        title=(\n            f\"Configs: {n_configs};\\n\"\n            f\"Path: {str(parent_folder)};\\n\"\n            f\"Top N: {top_n}\"\n        ),\n        show_lines=True,\n    )\n\n    table.add_column(\"q\", justify=\"right\", style=\"cyan\", no_wrap=False)\n    table.add_column(\"cat\", style=\"magenta\", no_wrap=False)\n    table.add_column(\"geo\", style=\"magenta\", no_wrap=False)\n    table.add_column(\"timeframe\", style=\"magenta\", no_wrap=False)\n\n    for idx, c in enumerate(self.config_bundle):\n        if idx &gt; top_n:\n            break\n        else:\n            table.add_row(\n                c.serpapi_params.q,\n                c.serpapi_params.cat,\n                c.serpapi_params.geo,\n                c.serpapi_params.date,\n            )\n\n    return table\n</code></pre>"},{"location":"references/utilities/config/#sm_trendy.utilities.config.PathParams","title":"<code>PathParams</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>parameters to be used to build the folder path of the data files.</p> <p>Note</p> <p>We will have to keep the order of the parameters.</p> <p>Pydantic already tries to provide ordered schema. In addition, we added a property called <code>path_schema</code>.</p> Source code in <code>sm_trendy/utilities/config.py</code> <pre><code>class PathParams(BaseModel):\n\"\"\"parameters to be used to build the folder\n    path of the data files.\n\n    !!! note\n\n        We will have to keep the order of the parameters.\n\n        Pydantic already tries to provide ordered schema.\n        In addition, we added a property called `path_schema`.\n    \"\"\"\n\n    keyword: str\n    cat: str\n    geo: str\n    timeframe: str\n\n    @property\n    def path_schema(self) -&gt; OrderedDict:\n\"\"\"Ordered dictionary for the path schema\n\n        Note that keyword and category will be slugified\n        \"\"\"\n        return OrderedDict(\n            [\n                (\"keyword\", slugify(self.keyword)),\n                (\"cat\", slugify(self.cat)),\n                (\"geo\", slugify(self.geo)),\n                (\"timeframe\", slugify(self.timeframe)),\n            ]\n        )\n\n    def path(self, parent_folder: AnyPath) -&gt; AnyPath:\n\"\"\"build the path under the parent folder\n\n        :param parent_folder: base path\n        \"\"\"\n        if not isinstance(parent_folder, AnyPath):\n            parent_folder = AnyPath(parent_folder)\n        folder = parent_folder\n        for k in self.path_schema:\n            folder = folder / f\"{k}={self.path_schema[k]}\"\n\n        return folder\n\n    def s3_access_point(\n        self,\n        base_url: str,\n        snapshot_date: Union[datetime.date, Literal[\"latest\"]] = \"latest\",\n        format: Optional[Literal[\"json\"]] = \"json\",\n        filename: Optional[str] = \"data.json\",\n    ):\n\"\"\"\n        An access point is some kind of URL. For example\n        https://sm-google-trend-public.s3.eu-central-1.amazonaws.com/\n        agg/keyword=curtain/cat=0/geo=de/timeframe=today-5-y/format=json/\n        snapshot_date=latest/data.json\n\n        :param base_url: base url to append the path to\n        :param snapshot_date: snapshot of the file\n        :param filename: name of the file\n        \"\"\"\n        if base_url.endswith(\"/\"):\n            base_url = base_url[:-1]\n\n        url = base_url\n        for k in self.path_schema:\n            url += f\"/{k}={self.path_schema[k]}\"\n\n        url += f\"/format={format}/snapshot_date={snapshot_date}/{filename}\"\n\n        return url\n</code></pre>"},{"location":"references/utilities/config/#sm_trendy.utilities.config.PathParams.path_schema","title":"<code>path_schema: OrderedDict</code>  <code>property</code>","text":"<p>Ordered dictionary for the path schema</p> <p>Note that keyword and category will be slugified</p>"},{"location":"references/utilities/config/#sm_trendy.utilities.config.PathParams.path","title":"<code>path(parent_folder)</code>","text":"<p>build the path under the parent folder</p> <p>Parameters:</p> Name Type Description Default <code>parent_folder</code> <code>AnyPath</code> <p>base path</p> required Source code in <code>sm_trendy/utilities/config.py</code> <pre><code>def path(self, parent_folder: AnyPath) -&gt; AnyPath:\n\"\"\"build the path under the parent folder\n\n    :param parent_folder: base path\n    \"\"\"\n    if not isinstance(parent_folder, AnyPath):\n        parent_folder = AnyPath(parent_folder)\n    folder = parent_folder\n    for k in self.path_schema:\n        folder = folder / f\"{k}={self.path_schema[k]}\"\n\n    return folder\n</code></pre>"},{"location":"references/utilities/config/#sm_trendy.utilities.config.PathParams.s3_access_point","title":"<code>s3_access_point(base_url, snapshot_date='latest', format='json', filename='data.json')</code>","text":"<p>An access point is some kind of URL. For example https://sm-google-trend-public.s3.eu-central-1.amazonaws.com/ agg/keyword=curtain/cat=0/geo=de/timeframe=today-5-y/format=json/ snapshot_date=latest/data.json</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>base url to append the path to</p> required <code>snapshot_date</code> <code>Union[datetime.date, Literal['latest']]</code> <p>snapshot of the file</p> <code>'latest'</code> <code>filename</code> <code>Optional[str]</code> <p>name of the file</p> <code>'data.json'</code> Source code in <code>sm_trendy/utilities/config.py</code> <pre><code>def s3_access_point(\n    self,\n    base_url: str,\n    snapshot_date: Union[datetime.date, Literal[\"latest\"]] = \"latest\",\n    format: Optional[Literal[\"json\"]] = \"json\",\n    filename: Optional[str] = \"data.json\",\n):\n\"\"\"\n    An access point is some kind of URL. For example\n    https://sm-google-trend-public.s3.eu-central-1.amazonaws.com/\n    agg/keyword=curtain/cat=0/geo=de/timeframe=today-5-y/format=json/\n    snapshot_date=latest/data.json\n\n    :param base_url: base url to append the path to\n    :param snapshot_date: snapshot of the file\n    :param filename: name of the file\n    \"\"\"\n    if base_url.endswith(\"/\"):\n        base_url = base_url[:-1]\n\n    url = base_url\n    for k in self.path_schema:\n        url += f\"/{k}={self.path_schema[k]}\"\n\n    url += f\"/format={format}/snapshot_date={snapshot_date}/{filename}\"\n\n    return url\n</code></pre>"},{"location":"references/utilities/config/#sm_trendy.utilities.config.convert_path","title":"<code>convert_path(raw_config)</code>","text":"<p>Convert str representation of path to Path</p> <p>Parameters:</p> Name Type Description Default <code>raw_config</code> <code>Dict</code> <p>raw config</p> required Source code in <code>sm_trendy/utilities/config.py</code> <pre><code>def convert_path(raw_config: Dict) -&gt; Dict:\n\"\"\"Convert str representation of path to Path\n\n    :param raw_config: raw config\n    \"\"\"\n    keys = [\"parent_folder\"]\n    config = copy.deepcopy(raw_config)\n\n    for k in keys:\n        if (not isinstance(config.get(k), AnyPath)) and (config.get(k) is not None):\n            config[k] = config[k]\n\n    return config\n</code></pre>"},{"location":"references/utilities/request/","title":"Utilities - Request","text":""},{"location":"references/utilities/request/#utilities-request","title":"Utilities - Request","text":""},{"location":"references/utilities/request/#sm_trendy.utilities.request.get_random_user_agent","title":"<code>get_random_user_agent(browsers=None)</code>","text":"<p>get_random_user_agent returns a random user agent.</p> <p>We provide two predefined browers, chrome and firefox.</p> <p>Parameters:</p> Name Type Description Default <code>browsers</code> <code>list, optional</code> <p>which brower to be used, defaults to [\"chrome\", \"firefox\"]</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>dictionary for requests module to consude as {'User-Agent': \"blabla\"}</p> Source code in <code>sm_trendy/utilities/request.py</code> <pre><code>def get_random_user_agent(browsers=None):\n\"\"\"\n    get_random_user_agent returns a random user agent.\n\n    We provide two predefined browers, chrome and firefox.\n\n    :param browsers: which brower to be used, defaults to [\"chrome\", \"firefox\"]\n    :type browsers: list, optional\n    :return: dictionary for requests module to consude as {'User-Agent': \"blabla\"}\n    :rtype: dict\n    \"\"\"\n\n    if browsers is None:\n        browsers = [\"chrome\", \"firefox\"]\n    if isinstance(browsers, str):\n        browsers = [browsers]\n\n    chrome_user_agents = [\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36\",\n    ]\n    firefox_user_agents = [\n        \"Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1)\",\n        \"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)\",\n        \"Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (Windows NT 6.2; WOW64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0)\",\n        \"Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)\",\n        \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; Trident/7.0; rv:11.0) like Gecko\",\n        \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0)\",\n        \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)\",\n        \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\",\n    ]\n\n    user_agents_dict = {\"chrome\": chrome_user_agents, \"firefox\": firefox_user_agents}\n\n    # error if specified browser is not in the list\n    if set(browsers) - set(user_agents_dict.keys()):\n        logger.error(f\"Unknown browser: {set(browsers) - set(user_agents_dict.keys())}\")\n\n    user_agent_list = sum([user_agents_dict[browser] for browser in browsers], [])\n\n    return {\"User-Agent\": random.choice(user_agent_list)}\n</code></pre>"},{"location":"references/utilities/request/#sm_trendy.utilities.request.get_request_configs","title":"<code>get_request_configs(headers=None, timeout=None, proxies=None, cookies=None)</code>","text":"<p>get_session_query_configs creates a session config dictionary for session to use. These are the keyword arguments of the session get or post methods.</p> <p>Proxies can be set by providing a dictionary of the form</p> <pre><code>{\n    'http': some super_proxy_url,\n    'https': some super_proxy_url,\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>headers</code> <p>header of the method such as use agent, defaults to random user agent from get_random_user_agent</p> <code>None</code> <code>timeout</code> <p>timeout strategy, defaults to (5, 14)</p> <code>None</code> <code>proxies</code> <p>proxy configs, defaults to {}</p> <code>None</code> <p>Returns:</p> Type Description <p>dictionary of session configs for session methods, e.g., get, to use.</p> Source code in <code>sm_trendy/utilities/request.py</code> <pre><code>def get_request_configs(\n    headers=None,\n    timeout=None,\n    proxies=None,\n    cookies=None,\n):\n\"\"\"\n    get_session_query_configs creates a session config dictionary for session to use. These are the keyword arguments of the session get or post methods.\n\n    Proxies can be set by providing a dictionary of the form\n\n    ```python\n    {\n        'http': some super_proxy_url,\n        'https': some super_proxy_url,\n    }\n    ```\n\n    :param headers: header of the method such as use agent, defaults to random user agent from get_random_user_agent\n    :param timeout: timeout strategy, defaults to (5, 14)\n    :param proxies: proxy configs, defaults to {}\n    :return: dictionary of session configs for session methods, e.g., get, to use.\n    \"\"\"\n\n    if headers is None:\n        headers = get_random_user_agent()\n\n    if timeout is None:\n        timeout = (5, 14)\n\n    if proxies is None:\n        proxies = {}\n\n    return dict(headers=headers, proxies=proxies, timeout=timeout)\n</code></pre>"},{"location":"references/utilities/request/#sm_trendy.utilities.request.get_session","title":"<code>get_session(retry_params=None, session=None)</code>","text":"<p>get_session prepares a session object.</p> <p>Parameters:</p> Name Type Description Default <code>retry_params</code> <code>dict, optional</code> <p>the rules to retry, defaults to {\"retries\": 5, \"backoff_factor\": 0.3, \"status_forcelist\": (500, 502, 504)}</p> <code>None</code> <code>session</code> <code>[type], optional</code> <p>[description], defaults to None</p> <code>None</code> Source code in <code>sm_trendy/utilities/request.py</code> <pre><code>def get_session(\n    retry_params=None,\n    session=None,\n):\n\"\"\"\n    get_session prepares a session object.\n\n    :param retry_params: the rules to retry, defaults to {\"retries\": 5, \"backoff_factor\": 0.3, \"status_forcelist\": (500, 502, 504)}\n    :type retry_params: dict, optional\n    :param session: [description], defaults to None\n    :type session: [type], optional\n    \"\"\"\n\n    if retry_params is None:\n        retry_params = {\n            \"retries\": 5,\n            \"backoff_factor\": 0.3,\n            \"status_forcelist\": (500, 502, 504),\n        }\n\n    if session is None:\n        session = requests.Session()\n\n    retry = Retry(\n        total=retry_params.get(\"retries\"),\n        read=retry_params.get(\"retries\"),\n        connect=retry_params.get(\"retries\"),\n        backoff_factor=retry_params.get(\"backoff_factor\"),\n        status_forcelist=retry_params.get(\"status_forcelist\"),\n    )\n\n    adapter = HTTPAdapter(max_retries=retry)\n    session.mount(\"http://\", adapter)\n    session.mount(\"https://\", adapter)\n\n    return session\n</code></pre>"},{"location":"references/utilities/storage/","title":"Utilities - Storage","text":""},{"location":"references/utilities/storage/#utilities-storage","title":"Utilities - Storage","text":""},{"location":"references/utilities/storage/#sm_trendy.utilities.storage.StoreDataFrame","title":"<code>StoreDataFrame</code>","text":"<p>Save dataframe</p> <p>We follow the schema</p> <pre><code>target_folder / \"format=parquet\" / \"snapshot_date=\"\n</code></pre> <p><code>target_folder</code> should reflect what data is inside. For example, we may use</p> <pre><code>target_folder = some_folder / \"google_trend\"\n/ \"keyword=phone_case\" / \"cat=0\"\n/ \"geo=de\" / \"timeframe=today-5-y\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>target_folder</code> <code>AnyPath</code> <p>parent folder for the data. Note that subfolders will be created inside it.</p> required <code>snapshot_date</code> <code>datetime.date</code> <p>the date when the data was produced. Please stick to UTC date.</p> required Source code in <code>sm_trendy/utilities/storage.py</code> <pre><code>class StoreDataFrame:\n\"\"\"Save dataframe\n\n    We follow the schema\n\n    ```python\n    target_folder / \"format=parquet\" / \"snapshot_date=\"\n    ```\n\n    `target_folder` should reflect what data is inside.\n    For example, we may use\n\n    ```\n    target_folder = some_folder / \"google_trend\"\n    / \"keyword=phone_case\" / \"cat=0\"\n    / \"geo=de\" / \"timeframe=today-5-y\"\n    ```\n\n    :param target_folder: parent folder for the data.\n        Note that subfolders will be created inside it.\n    :param snapshot_date: the date when the data was produced.\n        Please stick to UTC date.\n    \"\"\"\n\n    def __init__(self, target_folder: AnyPath, snapshot_date: datetime.date):\n        self.target_folder = target_folder\n\n        if not isinstance(snapshot_date, datetime.date):\n            raise TypeError(\n                f\"snapshot_date provided is not date time: {type(snapshot_date)}\"\n            )\n        else:\n            self.snapshot_date = snapshot_date\n\n    def save(\n        self,\n        trend_data: Any,\n        formats: Optional[List[Literal[\"parquet\", \"csv\"]]],\n    ):\n\"\"\"\n        Save the trend results\n\n        :param trend_data: the object containing the dataframe and metadata\n        :param formats: which formats to save as\n        \"\"\"\n        df = trend_data.dataframe\n        metadata = trend_data.metadata\n\n        format_dispatcher = {\n            \"parquet\": {\n                \"method\": self._save_parquet,\n                \"path\": self._file_path(format=\"parquet\"),\n            },\n            \"csv\": {\n                \"method\": self._save_csv,\n                \"path\": self._file_path(format=\"csv\"),\n            },\n        }\n\n        for f in formats:\n            try:\n                f_method = format_dispatcher[f][\"method\"]\n                f_path_data = format_dispatcher[f][\"path\"][\"data\"]  # type: ignore\n                f_path_metadata = format_dispatcher[f][\"path\"][\"metadata\"]  # type: ignore\n\n                f_method(dataframe=df, target_path=f_path_data)  # type: ignore\n                self._save_metadata(metadata=metadata, target_path=f_path_metadata)\n            except Exception as e:\n                logger.error(f\"can not save format {f}: {e}\")\n\n        df = trend_data.dataframe\n\n    def _file_path(self, format: Literal[\"parquet\", \"csv\"]) -&gt; Dict[str, AnyPath]:\n\"\"\"Compute the full path for the target file\n        based on the format\n\n        :param format: the file format to be used\n        \"\"\"\n        folder = (\n            self.target_folder\n            / f\"format={format}\"\n            / f\"snapshot_date={self.snapshot_date.isoformat()}\"\n        )\n        if isinstance(folder, Path):\n            folder.mkdir(parents=True, exist_ok=True)\n        return {\n            \"data\": folder / f\"data.{format}\",\n            \"metadata\": folder / \"metadata.json\",\n        }\n\n    def _save_parquet(self, dataframe: pd.DataFrame, target_path: AnyPath):\n\"\"\"save a dataframe as parquet\n\n        :param dataframe: dataframe to be saved as file\n        :param target_path: the target file full path\n        \"\"\"\n        if isinstance(target_path, S3Path):\n            target_path = str(target_path)\n            logger.debug(\n                \"Converting S3Path to string for pandas compatability\\n\"\n                f\"{type(target_path)}: {target_path}\"\n            )\n        logger.debug(f\"Saving parquet format to {target_path} ...\")\n        dataframe.to_parquet(target_path)\n\n    def _save_csv(self, dataframe: pd.DataFrame, target_path: AnyPath):\n\"\"\"save a dataframe as csv\n\n        :param dataframe: dataframe to be saved as file\n        :param target_path: the target file full path\n        \"\"\"\n        if isinstance(target_path, S3Path):\n            target_path = str(target_path)\n            logger.debug(\n                \"Converting S3Path to string for pandas compatability\\n\"\n                f\"{type(target_path)}: {target_path}\"\n            )\n        logger.debug(f\"Saving csv format to {target_path} ...\")\n        dataframe.to_csv(target_path, index=False)\n\n    def _save_metadata(self, metadata: Dict, target_path: AnyPath):\n\"\"\"save metadata as a json file\n\n        :param metadata: metadata in dictionary format\n        :param target_path:\n        \"\"\"\n        logger.debug(f\"Saving metadata to {target_path} ...\")\n        with target_path.open(\"w+\") as fp:\n            json.dump(metadata, fp, indent=2)\n</code></pre>"},{"location":"references/utilities/storage/#sm_trendy.utilities.storage.StoreDataFrame.save","title":"<code>save(trend_data, formats)</code>","text":"<p>Save the trend results</p> <p>Parameters:</p> Name Type Description Default <code>trend_data</code> <code>Any</code> <p>the object containing the dataframe and metadata</p> required <code>formats</code> <code>Optional[List[Literal['parquet', 'csv']]]</code> <p>which formats to save as</p> required Source code in <code>sm_trendy/utilities/storage.py</code> <pre><code>def save(\n    self,\n    trend_data: Any,\n    formats: Optional[List[Literal[\"parquet\", \"csv\"]]],\n):\n\"\"\"\n    Save the trend results\n\n    :param trend_data: the object containing the dataframe and metadata\n    :param formats: which formats to save as\n    \"\"\"\n    df = trend_data.dataframe\n    metadata = trend_data.metadata\n\n    format_dispatcher = {\n        \"parquet\": {\n            \"method\": self._save_parquet,\n            \"path\": self._file_path(format=\"parquet\"),\n        },\n        \"csv\": {\n            \"method\": self._save_csv,\n            \"path\": self._file_path(format=\"csv\"),\n        },\n    }\n\n    for f in formats:\n        try:\n            f_method = format_dispatcher[f][\"method\"]\n            f_path_data = format_dispatcher[f][\"path\"][\"data\"]  # type: ignore\n            f_path_metadata = format_dispatcher[f][\"path\"][\"metadata\"]  # type: ignore\n\n            f_method(dataframe=df, target_path=f_path_data)  # type: ignore\n            self._save_metadata(metadata=metadata, target_path=f_path_metadata)\n        except Exception as e:\n            logger.error(f\"can not save format {f}: {e}\")\n\n    df = trend_data.dataframe\n</code></pre>"},{"location":"references/utilities/storage/#sm_trendy.utilities.storage.StoreJSON","title":"<code>StoreJSON</code>","text":"<p>Save json data</p> <p>We follow the schema</p> <pre><code>target_folder / \"format=parquet\" / \"snapshot_date=\"\n</code></pre> <p><code>target_folder</code> should reflect what data is inside. For example, we may use</p> <pre><code>target_folder = some_folder / \"google_trend\"\n/ \"keyword=phone_case\" / \"cat=0\"\n/ \"geo=de\" / \"timeframe=today-5-y\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>target_folder</code> <code>AnyPath</code> <p>parent folder for the data. Note that subfolders will be created inside it.</p> required <code>snapshot_date</code> <code>Union[datetime.date, Literal['latest']]</code> <p>the date when the data was produced. Please stick to UTC date.</p> required Source code in <code>sm_trendy/utilities/storage.py</code> <pre><code>class StoreJSON:\n\"\"\"Save json data\n\n    We follow the schema\n\n    ```python\n    target_folder / \"format=parquet\" / \"snapshot_date=\"\n    ```\n\n    `target_folder` should reflect what data is inside.\n    For example, we may use\n\n    ```\n    target_folder = some_folder / \"google_trend\"\n    / \"keyword=phone_case\" / \"cat=0\"\n    / \"geo=de\" / \"timeframe=today-5-y\"\n    ```\n\n    :param target_folder: parent folder for the data.\n        Note that subfolders will be created inside it.\n    :param snapshot_date: the date when the data was produced.\n        Please stick to UTC date.\n    \"\"\"\n\n    def __init__(\n        self,\n        target_folder: AnyPath,\n        snapshot_date: Union[datetime.date, Literal[\"latest\"]],\n    ):\n        self.target_folder = target_folder\n\n        if not isinstance(snapshot_date, (datetime.date, str)):\n            raise TypeError(\n                f\"snapshot_date provided is not date time: {type(snapshot_date)}\"\n            )\n        else:\n            self.snapshot_date = snapshot_date\n\n    def save(\n        self,\n        records: Any,\n        formats: Optional[List[Literal[\"json\"]]],\n    ):\n\"\"\"\n        Save the trend results\n\n        :param trend_data: the object containing the dataframe and metadata\n        :param formats: which formats to save as\n        \"\"\"\n        if not isinstance(formats, list):\n            formats = [formats]\n\n        format_dispatcher = {\n            \"json\": {\n                \"method\": self._save_json,\n                \"path\": self._file_path(format=\"json\"),\n            },\n        }\n\n        for f in formats:\n            try:\n                f_method = format_dispatcher[f][\"method\"]\n                f_path_data = format_dispatcher[f][\"path\"][\"data\"]  # type: ignore\n\n                f_method(records=records, target_path=f_path_data)  # type: ignore\n            except Exception as e:\n                logger.error(f\"can not save format {f}: {e}\")\n\n    @property\n    def snapshot_date_str(self):\n        if isinstance(self.snapshot_date, datetime.date):\n            return self.snapshot_date.isoformat()\n        elif self.snapshot_date == \"latest\":\n            return self.snapshot_date\n        else:\n            raise ValueError(f\"snapshot_date {self.snapshot_date} is not supported\")\n\n    def _file_path(self, format: Literal[\"json\"]) -&gt; Dict[str, AnyPath]:\n\"\"\"Compute the full path for the target file\n        based on the format\n\n        :param format: the file format to be used\n        \"\"\"\n        folder = (\n            self.target_folder\n            / f\"format={format}\"\n            / f\"snapshot_date={self.snapshot_date_str}\"\n        )\n        if isinstance(folder, Path):\n            folder.mkdir(parents=True, exist_ok=True)\n        return {\"data\": folder / f\"data.{format}\"}\n\n    def _save_json(self, records: Dict, target_path: AnyPath):\n\"\"\"save a dataframe as json\n\n        :param records: records to be saved as file\n        :param target_path: the target file full path\n        \"\"\"\n        logger.debug(f\"Saving json format to {target_path} ...\")\n        with target_path.open(\"w+\") as fp:\n            json.dump(records, fp)\n</code></pre>"},{"location":"references/utilities/storage/#sm_trendy.utilities.storage.StoreJSON.save","title":"<code>save(records, formats)</code>","text":"<p>Save the trend results</p> <p>Parameters:</p> Name Type Description Default <code>trend_data</code> <p>the object containing the dataframe and metadata</p> required <code>formats</code> <code>Optional[List[Literal['json']]]</code> <p>which formats to save as</p> required Source code in <code>sm_trendy/utilities/storage.py</code> <pre><code>def save(\n    self,\n    records: Any,\n    formats: Optional[List[Literal[\"json\"]]],\n):\n\"\"\"\n    Save the trend results\n\n    :param trend_data: the object containing the dataframe and metadata\n    :param formats: which formats to save as\n    \"\"\"\n    if not isinstance(formats, list):\n        formats = [formats]\n\n    format_dispatcher = {\n        \"json\": {\n            \"method\": self._save_json,\n            \"path\": self._file_path(format=\"json\"),\n        },\n    }\n\n    for f in formats:\n        try:\n            f_method = format_dispatcher[f][\"method\"]\n            f_path_data = format_dispatcher[f][\"path\"][\"data\"]  # type: ignore\n\n            f_method(records=records, target_path=f_path_data)  # type: ignore\n        except Exception as e:\n            logger.error(f\"can not save format {f}: {e}\")\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":""}]}